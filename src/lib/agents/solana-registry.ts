
import { Connection, PublicKey } from "@solana/web3.js";
import { Program, AnchorProvider, Idl, web3 } from "@project-serum/anchor";
import { getNetworkConfig } from "@/lib/payments/x402-chains";

// Placeholder IDL - Would be generated by Anchor build
const IDL: Idl = {
    version: "0.1.0",
    name: "solana_agent_registry",
    instructions: [
        {
            name: "registerAgent",
            accounts: [
                { name: "agentProfile", isMut: true, isSigner: false },
                { name: "authority", isMut: true, isSigner: true },
                { name: "systemProgram", isMut: false, isSigner: false }
            ],
            args: [
                { name: "name", type: "string" },
                { name: "endpoint", type: "string" },
                { name: "capabilities", type: { vec: "string" } }
            ]
        }
    ],
    accounts: [
        {
            name: "AgentProfile",
            type: {
                kind: "struct",
                fields: [
                    { name: "authority", type: "publicKey" },
                    { name: "name", type: "string" },
                    { name: "endpoint", type: "string" },
                    { name: "capabilities", type: { vec: "string" } },
                    { name: "baseFee", type: "u64" },
                    { name: "assetMint", type: "publicKey" },
                    { name: "reputationScore", type: "u64" },
                    { name: "totalJobs", type: "u64" },
                    { name: "isActive", type: "bool" }
                ]
            }
        }
    ]
};

// Program ID (Deployed to Devnet)
const PROGRAM_ID = new PublicKey("9u4eVWRf8a7vMDCHsguakB6vxcnCuJssBVBbQAYrKdog");

export interface AgentProfile {
    publicKey: PublicKey;
    account: {
        authority: PublicKey;
        name: string;
        endpoint: string;
        capabilities: string[];
        baseFee: number; // Converted from u64
        reputationScore: number;
        isActive: boolean;
    };
}

export class SolanaAgentRegistry {
    connection: Connection;
    program: Program;

    constructor(connection: Connection, wallet?: any) {
        this.connection = connection;

        // Read-only provider if wallet not connected
        const provider = new AnchorProvider(
            connection,
            wallet || {
                signTransaction: () => Promise.reject(),
                signAllTransactions: () => Promise.reject(),
                publicKey: PublicKey.default
            },
            AnchorProvider.defaultOptions()
        );

        this.program = new Program(IDL, PROGRAM_ID, provider);
    }

    /**
     * Fetch a specific agent profile
     */
    async getAgentProfile(agentAddress: PublicKey): Promise<AgentProfile | null> {
        try {
            const [pda] = PublicKey.findProgramAddressSync(
                [Buffer.from("agent_profile"), agentAddress.toBuffer()],
                this.program.programId
            );

            const account: any = await this.program.account.agentProfile.fetch(pda);

            return {
                publicKey: pda,
                account: {
                    authority: account.authority,
                    name: account.name,
                    endpoint: account.endpoint,
                    capabilities: account.capabilities,
                    baseFee: account.baseFee.toNumber(),
                    reputationScore: account.reputationScore.toNumber(),
                    isActive: account.isActive
                }
            };
        } catch (e) {
            console.warn(`Agent profile not found for ${agentAddress.toBase58()}`);
            return null;
        }
    }

    /**
     * get all agents (mock filter for now as getProgramAccounts can be heavy)
     */
    async getAllAgents(): Promise<AgentProfile[]> {
        try {
            // In production, use getProgramAccounts with memcmp filters
            // This is a simplified fetch of all agent accounts
            const accounts = await this.program.account.agentProfile.all();

            return accounts.map(a => ({
                publicKey: a.publicKey,
                account: {
                    authority: a.account.authority,
                    name: a.account.name,
                    endpoint: a.account.endpoint,
                    capabilities: a.account.capabilities as string[],
                    baseFee: (a.account.baseFee as any).toNumber(),
                    reputationScore: (a.account.reputationScore as any).toNumber(),
                    isActive: a.account.isActive as boolean
                }
            }));
        } catch (e) {
            console.error("Failed to fetch agents", e);
            return [];
        }
    }
}
